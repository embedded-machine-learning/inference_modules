# The PyARMNN profiler delivers per layer statistics, but is not used due to the black box approach
# The compiled benchmark delivers profile csv per network execution

__author__ = "Matvey Ivanov"
__copyright__ = "Christian Doppler Laboratory for Embedded Machine Learning"
__license__ = "Apache 2.0"

import os, logging
import pandas, json
from pathlib import Path

def add_measured_to_input(time_df, input_df, measured_df):
    return True

def read_report(report="", outfolder="./tmp/"):
    """Reads file in a pandas dataframe and writes layer data into a pickle file

    Args:
        outfolder: folder where the pickled data will be stored
        report: filename of the report where the data will be extracted

    Returns: False if File does not exist 
    """

    # check if parsed report file exists 
    if not os.path.exists(Path(report)):
        return False

    # black lines are needed to find the correct indices
    data = pandas.read_csv(Path(report), sep=",", header=2, skip_blank_lines=False)
    data.columns = ["node type","first [ms]","avg [ms]","%","cdf%","mem KB", "times called", "name"]

    delegate_index = None # there should be only one in the file
    operator_wise_index = None # there should be only one in the file
    whitespace_indices = []
    next_whitespace = None

    for i, d in enumerate(data["node type"]):
        # Use data after Delegate internal if it exists in file 
        if "Delegate internal:" in str(d):
            delegate_index = i # save the delegate index
        # Use Operator-wise Profiling Info for Regular Benchmark Runs: if it exists in file
        if "Operator-wise Profiling Info for Regular Benchmark Runs:" in str(d):
            operator_wise_index = i
        if str(d) == "nan":
            whitespace_indices.append(i)

    print("Delegate Internal index: {}, Operator-wise* index: {}".format(delegate_index, operator_wise_index))
    print("Whitespace indices:", whitespace_indices)

    # get layer information starting from one of the indices + 2 (Err:510, node type) till an empty row
    # find the next largest whitespace index compared to either delegate* or operation wise*
    if delegate_index:
        # delegate* is mightier than operation-wise*
        start_index = delegate_index
        next_whitespace = [val for val in whitespace_indices if val > delegate_index][0] 
    elif operator_wise_index and not delegate_index:
        # only operation-wise* is valid
        start_index = operator_wise_index
        next_whitespace = [val for val in whitespace_indices if val > operator_wise_index][0]
    else:
        print("No Delegate internal or Operator-wise* in file, data cannot be extracted!")
        return

    print("next_whitespace:", next_whitespace)
    # change all "[" and "]" to "" in LayerName, remove \t
    for i, elem in enumerate(data["name"]):
        elem = elem.replace("[", "") if "[" in str(elem) else elem
        elem = elem.replace("]", "") if "]" in str(elem) else elem
        elem = elem.replace("\t", " ") if "\t" in str(elem) else elem
        data["name"][i] = elem

    data.drop(["mem KB", "times called"], axis=1, inplace=True)
    data_subset = data.iloc[start_index+3:next_whitespace]
    print(data_subset)
    
    # construct the json file name from the report name
    outfile = "".join(str(report).split(".csv")[0].split("/")[1])
    logging.debug(outfile)
    
    _ = data_subset.to_json(os.path.join(outfolder, outfile + ".json"), orient='index')
    
    return data_subset

def r2a(report="", outfolder="./tmp/"):
    data = read_report(report, outfolder)

    if data is False:
        return False

    result = pandas.DataFrame(data[["name","avg [ms]"]].to_numpy(),columns=['name','time(ms)'])
    print(data)
    print(result)

    return result

def extract_data_from_folder(infold, outfold):
    """Extracts layer name and real time data from a folder of ncs2 reports

    Args:
        infold: folder containing the reports generated by benchmark_app.py
        outfold: folder where the extracted results will be saved

    Returns: none
    """

    return True

if __name__ == "__main__":
    print("RPi4 Parser")
    import argparse
    parser = argparse.ArgumentParser(description='Raspberry Pi 4 network profile parser')
    parser.add_argument("-if", '--infold', default='./report',
                        help='Folder containing reports', required=False)
    parser.add_argument("-ir", '--inreport', default='./reports/report.csv',
                        help='Path to a report', required=False)
    parser.add_argument("-of", '--outfold', default='reports_extracted',
                        help='folder which will contain the output files', required=False)
    args = parser.parse_args()

    if not os.path.isdir(args.outfold):
        os.makedirs(args.outfold)

    data = r2a(report=args.inreport, outfolder=args.outfold)
    #extract_data_from_folder(args.infold, args.outfold)